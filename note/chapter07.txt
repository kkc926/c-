----------------------포인터

핵심!! 
-접근하려는 데이터가 어디있는가? 
스택(어떤함수의 프레임안인지):일반, 참조 포인터로 접근 가능 or 힙: 포인터로만 접근가능
-변수가 어떻게 표현되었는가
-데이터 접근을 위한 올바른 표현인가

메모리의 주소값을 저장하는 변수

■ 포인터(pointer)
 메모리의 주소값을 저장하는 변수
 변수 선언시 타입 뒤에 *를 지정

int *p; // 정수를 가리키는 포인터 선언


■ 주소 연산자 &
 기존 변수의 주소 값을 획득하여 포인터 변수에 저장할 때 사용

int number = 10;
int *p; // 정수를 가리키는 포인터 선언
p = &number; // 변수number의 주소를 p에 대입
p = 100; // 주소 100을 p에 대입

■ 간접 참조 연산자 *
 포인터 변수에는 주소가 저장되어있음
 그 주소에 저장되어 있는 데이터를 얻을 때 사용

cout << *p << endl; --> 10이 출력됨 (p가 가르키는 주소의 변수인 number의 값)
-----
#include<iostream>
#include<string>
using namespace std;
int main(int argc, char const *argv[]){
   int number = 0;
   int *p = &number;  //p변수는 number와 같이 int 여야한다. 다르면 에러

   cout << p << endl;
   cout << *p << endl;
   return 0;
}
-----

파이썬의 참조값은 주소를 가져온다는 것에서 포인터와 비슷하지만
참조변수의 값을 알 수 없다는 점과, 직접 주소를 설정할수 없는 제한적인 기능만 가능하다
ex 참조변수 c가 있을때 c=1000 불가능, print(c) 불가능 
또한 heap의 자료만 참조가능하여 stack의 자료는 참조불가능

포인터 변수는 관례상 변수명 앞에 p를 쓴다
ex> int number=100;
int *pNumber=&number;
cout << *pNumber;

■ NULL (ascii code 0)
 포인터가 아무것도 가리키지 않는 것을 의미하는 특수한 데이터
 0으로 해석되므로 int이기도 하면서 포인터 이기도 함
 포인터 변수를 초기화할 때 사용
 nullptr 사용 가능
 포인터로만 해석
----
#include<iostream>
#include<string>
using namespace std;
void f(int i) { 
    cout << "f(int)" << endl;
}
void f(char *p){
    cout << "f(char *)"<<endl;

}
int main(int argc, char const *argv[]){
    int *pNumber=NULL;//권장
    int *pNumber2;//비권장


    if (pNumber != NULL){  //초기값이 없으면 실행하지 말것
        cout <<*pNumber<<endl;
    }

    if (pNumber2 != NULL){ //?????????? 뭐가 나올지 모름 항상바뀜
        cout <<*pNumber2<<endl;
    }



   //f(NULL); -- int,char *  둘다 가능하므로 에러
   f(nullptr); //포인터널이므로 아래함수가 호출된다.
   f(0);// 숫자으므로 위의 함수가 호출된다.
   return 0;
}
----------

■ 프로그램에서의 메모리
- 스택(Stack)
 지역 변수 할당 (정적할당)
 시스템에 의해 관리 (함수호출) -->규칙 :선언할때 할당, 함수끝날때 삭제
- 힙(Heap)
 동적 메모리 할당(개발자에 의해 생성시점(new)과 삭제(delete)시점이 정해진다) 
 개발자에 의해 관리
    설정안하면 스택에 만들어짐(스택이 디폴트)
-------
 -new
 동적으로 힙에 메모리를 할당
 -delete
 동적으로 힙에 할당된 메모리를 회수
 파괴자가 호출됨
 동적 메모리를 회수 하지않으면 가비지(garbage) 증가 -- 메모리 누수

new int를 하면 heap에 4바이트 공간이 확보된다
cout << new int; 를 하면 주소값이 나온다
따라서 주소값을 저장할 수 있는 변수인 포인터 변수에만 대입가능
ex) int *a=new int;


int main(....){
int * pNumber;
.
.
.
.
delete pNumber; //new 로 힙에 데이터를 생성하지 않고 삭제하는 경우 프로그램이 죽는경우가 생김
따라서
int main(.....){
int * pNumber=null;
.
.
.
if (pNumber != null){ // 이게 안전함.
delete pNumber}

-----------------
int *pA=new int(10);

int *pB=pA; (pA가 주소이므로 포인터 pB에 대입가능)

delete pA;
delete pB;//// 이미 pA로 지웠기 때문에 pB가 실행될때 죽게된다

정리 : 동적데이터 설정시 죽는경우 2가지 1. new로 값설정을 안하고 지우는 경우, 2. 같은 데이터를 두번 지우는 경우
이것을 보완한 smart pointer가 있다.